function [X,label] = get_qam(M)
%GET_QAM Initialization of M-Quadrature-Amplitude-Modulation (M-QAM)
%constellation. Outputs the points and the labels of an M-QAM constellation
%with unit average power.
%
% Inputs:
%   M:  Number of symbols in the QAM constellation
%
% Outputs:
%   X:      Vector of dimension 1xM containing the M symbols of the QAM
%           constellation
%   label:  Matrix of size Mxm containing the binary labels of the M QAM
%           symbols where m=log2(M)


X = zeros(1,M);
label = zeros(M,log2(M));
level = sqrt(M); % if you have M symbols the width = length = sqrt(M)


if mod(M, 2) == 0
   R = +modulation.get_ask(level); % real achse
   I = R;                          % imaginary achse  

   [R_mat, I_mat]= meshgrid(R, I);

    X_mat = R_mat + 1j*I_mat;
  

% unit average energy = 1
sum_X_mat = sum(abs(X_mat).^2, 'all'); % energy of komplex signal: abs(x)^2 = x . x^* 
   
x = sqrt(M)/sum_X_mat;

X_norm = times(X_mat, x);
 

% We reshape matrix X_norm to a row vector X
X = X_norm(:).'; 

m = log2(M);


%Create the gray label for M-QAM
gray_1D = +modulation.get_gray_label(m/2); % size of  gray-1D : level x (m/2)
                                           % a QAM symbol carries m bits in total, but since QAM has two independent axes (I and R),the bits are split equally:m/2 bits for I and m/2 bitsfor R
                                           
                                           
                                                                                          
k = 1;
for col = 1 : level
    for row = 1: level
        gray_I = gray_1D(col,:); % I-achse gray code
        gray_R = gray_1D(row,:); % R-achse gray code
        label(k,:) = [gray_I, gray_R]; % total m bits
        k = k + 1;
    end
end 

end    

end


